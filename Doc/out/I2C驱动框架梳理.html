<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>1&period; &#x524d;&#x8a00;&#x5bfc;&#x5f15;</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension vscode.markdown-math */
@font-face{font-family:KaTeX_AMS;font-style:normal;font-weight:400;src:url(fonts/KaTeX_AMS-Regular.woff2) format("woff2"),url(fonts/KaTeX_AMS-Regular.woff) format("woff"),url(fonts/KaTeX_AMS-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Caligraphic-Bold.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Bold.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Caligraphic-Regular.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Regular.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Fraktur-Bold.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Bold.woff) format("woff"),url(fonts/KaTeX_Fraktur-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Fraktur-Regular.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Regular.woff) format("woff"),url(fonts/KaTeX_Fraktur-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Main-Bold.woff2) format("woff2"),url(fonts/KaTeX_Main-Bold.woff) format("woff"),url(fonts/KaTeX_Main-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Main-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Main-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Main-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Main-Italic.woff2) format("woff2"),url(fonts/KaTeX_Main-Italic.woff) format("woff"),url(fonts/KaTeX_Main-Italic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Main-Regular.woff2) format("woff2"),url(fonts/KaTeX_Main-Regular.woff) format("woff"),url(fonts/KaTeX_Main-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Math-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Math-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Math-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Math-Italic.woff2) format("woff2"),url(fonts/KaTeX_Math-Italic.woff) format("woff"),url(fonts/KaTeX_Math-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:700;src:url(fonts/KaTeX_SansSerif-Bold.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Bold.woff) format("woff"),url(fonts/KaTeX_SansSerif-Bold.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:italic;font-weight:400;src:url(fonts/KaTeX_SansSerif-Italic.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Italic.woff) format("woff"),url(fonts/KaTeX_SansSerif-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:400;src:url(fonts/KaTeX_SansSerif-Regular.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Regular.woff) format("woff"),url(fonts/KaTeX_SansSerif-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Script;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Script-Regular.woff2) format("woff2"),url(fonts/KaTeX_Script-Regular.woff) format("woff"),url(fonts/KaTeX_Script-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size1;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size1-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size1-Regular.woff) format("woff"),url(fonts/KaTeX_Size1-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size2;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size2-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size2-Regular.woff) format("woff"),url(fonts/KaTeX_Size2-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size3;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size3-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size3-Regular.woff) format("woff"),url(fonts/KaTeX_Size3-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size4;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size4-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size4-Regular.woff) format("woff"),url(fonts/KaTeX_Size4-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Typewriter;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Typewriter-Regular.woff2) format("woff2"),url(fonts/KaTeX_Typewriter-Regular.woff) format("woff"),url(fonts/KaTeX_Typewriter-Regular.ttf) format("truetype")}.katex{text-rendering:auto;font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0}.katex *{-ms-high-contrast-adjust:none!important;border-color:currentColor}.katex .katex-version:after{content:"0.13.24"}.katex .katex-mathml{clip:rect(1px,1px,1px,1px);border:0;height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-style:italic;font-weight:700}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;position:relative;vertical-align:bottom}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.katex .vbox{align-items:baseline;display:inline-flex;flex-direction:column}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{max-width:0;width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{position:relative;width:0}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{border:0 solid;display:inline-block;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline{border-bottom-style:dashed;display:inline-block;width:100%}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.katex svg path{stroke:none}.katex img{border-style:none;max-height:none;max-width:none;min-height:0;min-width:0}.katex .stretchy{display:block;overflow:hidden;position:relative;width:100%}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{overflow:hidden;position:relative;width:100%}.katex .halfarrow-left{left:0;overflow:hidden;position:absolute;width:50.2%}.katex .halfarrow-right{overflow:hidden;position:absolute;right:0;width:50.2%}.katex .brace-left{left:0;overflow:hidden;position:absolute;width:25.1%}.katex .brace-center{left:25%;overflow:hidden;position:absolute;width:50%}.katex .brace-right{overflow:hidden;position:absolute;right:0;width:25.1%}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{border:.04em solid;box-sizing:border-box}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{border-right:.049em solid;border-top:.049em solid;box-sizing:border-box;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{content:"(" counter(katexEqnNo) ")";counter-increment:katexEqnNo}.katex .mml-eqn-num:before{content:"(" counter(mmlEqnNo) ")";counter-increment:mmlEqnNo}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;left:calc(50% + .3em);position:absolute;text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{padding-left:2em;text-align:left}body{counter-reset:katexEqnNo mmlEqnNo}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.katex-error {
	color: var(--vscode-editorError-foreground);
}

/* From extension ms-toolsai.jupyter */
/* These classnames are inherited from bootstrap, but are present in most notebook renderers */

.alert {
    width: auto;
    padding: 1em;
    margin-top: 1em;
    margin-bottom: 1em;
}
.alert > *:last-child {
    margin-bottom: 0;
}
#preview > .alert:last-child {
    /* Prevent this being set to zero by the default notebook stylesheet */
    padding-bottom: 1em;
}

.alert-success {
    /* Note there is no suitable color available, so we just copy "info" */
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-info {
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-warning {
    background-color: var(--theme-warning-background);
    color: var(--theme-warning-foreground);
}
.alert-danger {
    background-color: var(--theme-error-background);
    color: var(--theme-error-foreground);
}

</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <ul>
<li><a href="#1-%E5%89%8D%E8%A8%80%E5%AF%BC%E5%BC%95">1. 前言导引</a></li>
<li><a href="#2-linux%E4%B8%ADi2c%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88">2. Linux中I2C驱动架构总览</a>
<ul>
<li><a href="#21-i2c%E6%A0%B8%E5%BF%83">2.1. I2C核心</a></li>
<li><a href="#22-i2c%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8">2.2. I2C总线驱动</a></li>
<li><a href="#23-i2c%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8">2.3. I2C设备驱动</a></li>
</ul>
</li>
<li><a href="#3-linux%E4%B8%ADi2c%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E6%80%BB%E8%A7%88">3. Linux中I2C驱动框架代码结构总览</a>
<ul>
<li><a href="#31-%E5%85%B3%E9%94%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84">3.1. 关键文件路径</a>
<ul>
<li><a href="#311-%E6%A0%B8%E5%BF%83%E5%B1%82%E5%92%8C%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8">3.1.1. 核心层和总线驱动</a></li>
<li><a href="#312-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%BB%A5gt1x%E8%A7%A6%E6%91%B8%E5%B1%8F%E4%B8%BA%E4%BE%8B">3.1.2. 设备驱动(以gt1x触摸屏为例)</a></li>
<li><a href="#313-%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%87%E4%BB%B6%E4%BB%A5tb-rk3568x%E4%B8%BA%E4%BE%8B">3.1.3. 设备树文件(以TB-RK3568X为例)</a></li>
<li><a href="#314-%E9%87%8D%E8%A6%81%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6">3.1.4. 重要的头文件</a></li>
</ul>
</li>
<li><a href="#32-%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">3.2. 关键数据结构</a>
<ul>
<li><a href="#321-%E5%AE%9A%E4%B9%89">3.2.1. 定义</a></li>
<li><a href="#322-%E5%85%B3%E8%81%94">3.2.2. 关联</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-linux%E4%B8%ADi2c%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">4. Linux中I2C驱动框架代码流程分析</a>
<ul>
<li><a href="#41-%E6%B3%A8%E5%86%8Ci2c%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E5%B1%82%E4%B8%BB%E8%A6%81%E6%98%AF%E6%B3%A8%E5%86%8Ci2c%E6%80%BB%E7%BA%BF">4.1. 注册I2C子系统核心层(主要是注册I2C总线)</a></li>
<li><a href="#42-%E6%B3%A8%E5%86%8Ci2c_adapter%E5%B9%B6%E5%B0%86%E5%85%B6%E6%B7%BB%E5%8A%A0%E5%88%B0i2c%E6%80%BB%E7%BA%BF">4.2. 注册i2c_adapter并将其添加到I2C总线</a>
<ul>
<li><a href="#421-%E6%B3%A8%E5%86%8Ci2c_adapter%E5%88%B0platform%E6%80%BB%E7%BA%BF">4.2.1. 注册i2c_adapter到platform总线</a></li>
<li><a href="#422-%E5%B0%86i2c_adapter%E6%B7%BB%E5%8A%A0%E5%88%B0i2c%E6%80%BB%E7%BA%BF">4.2.2. 将i2c_adapter添加到I2C总线</a></li>
<li><a href="#423-%E6%80%BB%E7%BB%93">4.2.3. 总结</a></li>
</ul>
</li>
<li><a href="#43-i2c%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91">4.3. I2C设备驱动开发</a>
<ul>
<li><a href="#431-%E5%B0%86i2c%E6%8E%A7%E5%88%B6%E5%99%A8%E6%9A%B4%E9%9C%B2%E7%BB%99%E5%BA%94%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F">4.3.1. 将I2C控制器暴露给应用的方式</a></li>
<li><a href="#432-%E5%B0%86i2c%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8A%BD%E8%B1%A1%E6%88%90%E5%85%AC%E5%85%B1%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F">4.3.2. 将I2C控制器抽象成公共驱动的方式</a></li>
</ul>
</li>
<li><a href="#44-%E9%87%8D%E7%82%B9%E5%88%86%E6%9E%90">4.4. 重点分析</a>
<ul>
<li><a href="#441-%E4%BD%95%E6%97%B6%E8%B0%83%E7%94%A8match%E5%87%BD%E6%95%B0%E4%BD%95%E6%97%B6%E8%B0%83%E7%94%A8probe%E5%87%BD%E6%95%B0">4.4.1. 何时调用match()函数？何时调用probe()函数？</a></li>
<li><a href="#442-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%8C%B9%E9%85%8D%E6%9C%BA%E5%88%B6">4.4.2. 设备树匹配机制</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-%E7%BB%93%E8%AF%AD">5. 结语</a></li>
<li><a href="#6-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">6. 参考资料</a></li>
</ul>
<div STYLE="page-break-after: always;"></div>
<h1 id="1-前言导引">1. 前言导引</h1>
<p>I2C总线是Philips公司开发的一种简单、双向二线制同步串行总线，只需要两根线即可传送信息。I2C结合了SPI和UART的优点，可以像SPI一样将多个从机连接到单个主机，也可以使用多个主机控制一个或多个从机。</p>
<p>由于本文重点是梳理Linux中I2C驱动框架，所以对于I2C的通信协议、物理总线等基础内容不做过多赘述，读者可自行百度了解。</p>
<p>接下来，本文将从I2C驱动架构总览、I2C驱动框架代码结构总览、I2C驱动框架代码流程分析三个部分对I2C驱动框架进行梳理。</p>
<ul>
<li>I2C驱动架构总览主要介绍Linux中I2C驱动的整体架构，讲解各个组成部分的功能和相互联系。</li>
<li>I2C驱动框架代码结构总览主要介绍Linux中I2C驱动框架的重要文件路径和关键数据结构。</li>
<li>I2C驱动框架代码流程分析主要介绍Linux中I2C驱动框架的实现细节。</li>
</ul>
<div STYLE="page-break-after: always;"></div>
<h1 id="2-linux中i2c驱动架构总览">2. Linux中I2C驱动架构总览</h1>
<p>下图展示了Linux中I2C驱动架构的基本架构：</p>
<center>
<img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/Linux%E5%86%85%E6%A0%B8%E9%87%8CI2C%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6%E5%9B%BE.png?raw=true" width="80%" />
</center>
<p>对于南向开发而言，只需关注架构的内核空间部分。在《Linux设备驱动开发详解》一书第15章《Linux I2C核心、总线与设备驱动》中，将Linux内核里的I2C子系统分为核心、总线驱动和设备驱动三部分。</p>
<h2 id="21-i2c核心">2.1. I2C核心</h2>
<p>I2C核心提供了I2C总线驱动和I2C设备驱动注册和注销的方法，I2C通信方法上层的与具体适配器无关的代码，以及探测设备、检测设备地址的上层代码。I2C总线驱动和设备驱动之间依赖于I2C核心作为纽带。</p>
<h2 id="22-i2c总线驱动">2.2. I2C总线驱动</h2>
<p>I2C总线驱动是对SoC中I2C控制器的软件实现(i2c_algorithm)。提供I2C控制器与从设备间完成数据通信的能力(i2c_adapter)。对应软件架构图中硬件抽象层部分和硬件实现控制层。</p>
<h2 id="23-i2c设备驱动">2.3. I2C设备驱动</h2>
<p>I2C设备驱动(客户驱动)是对I2C从设备的软件实现。对应软件架构图中的驱动层。</p>
<div STYLE="page-break-after: always;"></div>
<h1 id="3-linux中i2c驱动框架代码结构总览">3. Linux中I2C驱动框架代码结构总览</h1>
<h2 id="31-关键文件路径">3.1. 关键文件路径</h2>
<h3 id="311-核心层和总线驱动">3.1.1. 核心层和总线驱动</h3>
<pre>
~/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/
├── algos               // i2c_algorithm相关，通信算法
├── busses              // i2c_adapter相关，已经编写好的各种向i2c核心层注册的适配器，与I2C总线驱动相关
├── muxes
├── i2c-boardinfo.c     // i2c静态声明i2c设备的文件，设备树出现后已经不太使用。
├── i2c-core-acpi.c     // 以下i2c-core-*.c对应老版本的i2c-core.c，对应I2C核心，由内核开发者实现的，与硬件无关的代码。主要为其他各部分提供操作接口，在其内部通过结构体里面的函数指针调用硬件相关信息，即结构体里面函数指针的函数在设备加载的时候初始化。
├── i2c-core-base.c
├── i2c-core.h
├── i2c-core-of.c
├── i2c-core-slave.c
├── i2c-core-smbus.c
├── i2c-dev.c           // 为i2c_adapter实现了设备文件功能，只是提供了通用的read()、write()和ioctl()等接口，供应用层直接控制I2C控制器访问I2C设备的存储空间或寄存器。
├── i2c-mux.c
├── i2c-slave-eeprom.c
├── i2c-slave-testunit.c
├── i2c-smbus.c         // 实现smbus协议的扩展文件
├── i2c-stub.c
├── Kconfig
└── Makefile
</pre>
<h3 id="312-设备驱动以gt1x触摸屏为例">3.1.2. 设备驱动(以gt1x触摸屏为例)</h3>
<pre>
~/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/input/touchscreen/gt1x/
├── gt1x.c              // gt1x触摸屏设备驱动主要代码位置
├── gt1x_cfg.h
├── gt1x_extents.c
├── gt1x_firmware.h
├── gt1x_generic.c      // gt1x触摸屏设备驱动主要代码位置
├── gt1x_generic.h
├── gt1x.h
├── gt1x_tools.c
├── gt1x_update.c
├── GT5688_Config_20170713_1080_1920.cfg
└── Makefile
</pre>
<h3 id="313-设备树文件以tb-rk3568x为例">3.1.3. 设备树文件(以TB-RK3568X为例)</h3>
<pre>
~/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/arch/arm64/boot/dts/rockchip/
├── ...
├── rk3568-toybrick-x0-linux.dts
├── rk3568.dtsi
├── rk3568-linux.dtsi
├── rk3568-toybrick-mipi-tx0-beiqicloud.dtsi
├── ...
</pre>
<h3 id="314-重要的头文件">3.1.4. 重要的头文件</h3>
<pre>
~/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/include/linux/
├── ...
├── device.h
├── ...
├── i2c.h
├── of.h
├── of_device.h
├── ...
</pre>
<h2 id="32-关键数据结构">3.2. 关键数据结构</h2>
<h3 id="321-定义">3.2.1. 定义</h3>
<table>
<thead>
<tr>
<th style="text-align:center">数据结构</th>
<th style="text-align:center">文件路径</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>i2c_adapter</code></td>
<td style="text-align:center"><code>/drivers/i2c/busses/i2c-core-base.c</code></td>
<td style="text-align:center">用于识别物理I2Cs总线以及访问该总线所需的访问算法</td>
</tr>
<tr>
<td style="text-align:center"><code>i2c_algorithm</code></td>
<td style="text-align:center"><code>/include/linux/i2c.h</code></td>
<td style="text-align:center">I2C通信方法</td>
</tr>
<tr>
<td style="text-align:center"><code>i2c_msg</code></td>
<td style="text-align:center"><code>/usr/include/linux/i2c.h</code></td>
<td style="text-align:center">i2c_algorithm中通信函数的基本单位</td>
</tr>
<tr>
<td style="text-align:center"><code>i2c_driver</code></td>
<td style="text-align:center"><code>/include/linux/i2c.h</code></td>
<td style="text-align:center">I2C设备驱动</td>
</tr>
<tr>
<td style="text-align:center"><code>i2c_client</code></td>
<td style="text-align:center"><code>/include/linux/i2c.h</code></td>
<td style="text-align:center">I2C从机设备</td>
</tr>
<tr>
<td style="text-align:center"><code>i2c_bus_type</code></td>
<td style="text-align:center"><code>/drivers/i2c/i2c-core-base.c</code></td>
<td style="text-align:center">I2C总线</td>
</tr>
</tbody>
</table>
<h3 id="322-关联">3.2.2. 关联</h3>
<p>下图解释了上述结构体之间的关联。在I2C设备驱动注册的过程中，会调用i2c_driver的匹配函数<code>match()</code>与i2c_client(在i2c_adapter注册过程中解析设备树信息生成)进行匹配，匹配成功则调用<code>probe()</code>函数完成驱动注册的收尾工作。设备驱动可通过i2c_adapter中提供的i2c_algorithm，构造i2c_msg与I2C设备通信，完成控制操作。</p>
<center>
<img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E5%85%B3%E8%81%94.png?raw=true" width="40%" />
</center>
<div STYLE="page-break-after: always;"></div>
<h1 id="4-linux中i2c驱动框架代码流程分析">4. Linux中I2C驱动框架代码流程分析</h1>
<center>
<img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/%E5%9B%BE%E7%89%872.png?raw=true" width="100%" />
</center>
<p>每一个i2c_adapter对应一条实际的I2C总线。I2C总线上挂载着多个I2C设备实物，每个I2C设备对应一个i2c_client。一般来说，一个i2c_driver可以匹配多个i2c_client，而一个i2c_client只能匹配一个i2c_driver。i2c_driver会给每个I2C设备注册设备节点(以字符设备节点为例)，向用户层提供标准操作接口，如<code>write()/read()/ioctl()</code>。通过调用i2c_adapter提供的通信方法i2c_algorithm，完成对I2C设备的操作。</p>
<p>根据上图展示的I2C驱动框架可以总结出构建流程如下：</p>
<h2 id="41-注册i2c子系统核心层主要是注册i2c总线">4.1. 注册I2C子系统核心层(主要是注册I2C总线)</h2>
<p>如果要在系统启动时便能享受到I2C总线的相关服务，就需要调用<code>i2c_init()</code>函数。该函数通过<code>postcore_initcall(i2c_init)</code>被放置在内核中的<code>initcall2.init</code>段处，这和驱动开发中调用<code>module_init()</code>类似。于是，在内核启动时，系统调用<code>do_initcall()</code>函数，根据指针数组<code>initcall_levels[2]</code>找到<code>__initcall2_start</code>指针。由<code>vmlinux.lds.h</code>可知，该指针指向<code>initcall2.init</code>段的起始地址，系统依次取出段中的每个函数指针并执行，从而使得系统能享受到I2C总线的相关服务。同样，编译进内核的驱动程序都通过这种方式完成启动并提供服务，具体可以查询“Linux的initcall机制”进行了解。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/i2c-core-base.c */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">i2c_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">int</span> retval;
	...
	retval = bus_register(&amp;i2c_bus_type);       <span class="hljs-comment">// 注册I2C总线，成功返回值为0</span>
	<span class="hljs-keyword">if</span> (retval)		<span class="hljs-comment">// 如果注册失败</span>
		<span class="hljs-keyword">return</span> retval;
	...
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
...
}
</div></code></pre>
<p><code>i2c_init()</code>函数中，最重要的便是调用<code>bus_register(&amp;i2c_bus_type)</code>函数完成I2C总线的注册。</p>
<p><code>i2c_bus_type</code>是一个<code>bus_type</code>结构体变量，它重载了<code>bus_type</code>结构体中的几个成员指针变量，其中最重要的是总线名称<code>.name</code>以及两个函数指针——<code>match()</code>和<code>probe()</code>。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/i2c-core-base.c */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> <span class="hljs-title">i2c_bus_type</span> =</span> {
	.name		= <span class="hljs-string">&quot;i2c&quot;</span>,
	.match		= i2c_device_match,         <span class="hljs-comment">// 负责总线上的device和driver匹配</span>
	.probe		= i2c_device_probe,         <span class="hljs-comment">// 在匹配成功后会执行以完成注册的收尾工作</span>
	.remove		= i2c_device_remove,
	.shutdown	= i2c_device_shutdown,
};
EXPORT_SYMBOL_GPL(i2c_bus_type);        <span class="hljs-comment">// 模块导出，可供其他模块使用</span>
</div></code></pre>
<p>当任何一个i2c_driver或者i2c_client注册到I2C总线时，I2C总线都会调用<code>i2c_device_match()</code>函数对i2c_driver和i2c_client进行匹配。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/i2c-core-base.c */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">i2c_device_match</span><span class="hljs-params">(struct device *dev, struct device_driver *drv)</span>
</span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span>	*<span class="hljs-title">client</span> =</span> i2c_verify_client(dev);
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span>	*<span class="hljs-title">driver</span>;</span>

	<span class="hljs-comment">/* Attempt an OF style match */</span>
	<span class="hljs-keyword">if</span> (i2c_of_match_device(drv-&gt;of_match_table, client))
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

	<span class="hljs-comment">/* Then ACPI style match */</span>
	<span class="hljs-keyword">if</span> (acpi_driver_match_device(dev, drv))
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

	driver = to_i2c_driver(drv);                    <span class="hljs-comment">// 找到i2c_driver</span>

	<span class="hljs-comment">/* Finally an I2C match */</span>
	<span class="hljs-keyword">if</span> (i2c_match_id(driver-&gt;id_table, client))     <span class="hljs-comment">// 用i2c_driver的id_table和device匹配。驱动名多个，但设备名只有一个，说明一个驱动可以对应多个设备(尤其是同一类型)</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p><code>i2c_device_match()</code>函数提供了三种匹配方式，它们执行顺序的先后代表了匹配优先级的高低。</p>
<ul>
<li><code>i2c_of_match_device</code>是设备树的匹配方式，具有最高的优先级。</li>
<li><code>acpi_driver_match_device</code>是acpi(高级设置与电源管理)的匹配方式。</li>
<li><code>i2c_match_id</code>则是通过注册i2c_driver结构体变量时提供的id_table进行匹配。</li>
</ul>
<p>如今设备树匹配方式已经成为主流，后文将对其进行重点介绍。而acpi匹配方式使用较少且较复杂，所以下面只简单了解一下在设备树匹配方式产生之前，主要采用的匹配方式<code>i2c_match_id</code>。</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">const</span> struct i2c_device_id *<span class="hljs-title">i2c_match_id</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct i2c_device_id *id,
						<span class="hljs-keyword">const</span> struct i2c_client *client)</span>
</span>{
	<span class="hljs-keyword">if</span> (!(id &amp;&amp; client))	<span class="hljs-comment">// 要求设备和驱动的设备号表都非空</span>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
	<span class="hljs-comment">// 循环比对</span>
	<span class="hljs-keyword">while</span> (id-&gt;name[<span class="hljs-number">0</span>]) {
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(client-&gt;name, id-&gt;name) == <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> id;
		id++;
	}
	<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}
</div></code></pre>
<p>匹配成功后，I2C总线在后续会调用<code>i2c_device_probe()</code>函数完成相应注册的收尾工作。</p>
<p>除了被重载的几个成员指针变量，<code>bus_type</code>结构体中还有一个关键成员变量<code>*p</code>。通过I2C驱动框架图可以知道，I2C总线上分别存储了i2c_driver链和i2c_client链来实现对驱动和设备的管理。<code>*p</code>是一个<code>subsys_private</code>结构体变量，所包含的成员<code>klist_devices</code>和<code>klist_drivers</code>分别对应了i2c_client链和i2c_driver链，在<code>bus_register()</code>中调用<code>klist_init()</code>函数进行初始化。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /include/linux/device/bus.h */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> {</span>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>		*name;
	...
	<span class="hljs-keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);
	<span class="hljs-keyword">int</span> (*probe)(struct device *dev);
	<span class="hljs-keyword">int</span> (*remove)(struct device *dev);
	<span class="hljs-keyword">void</span> (*shutdown)(struct device *dev);
	...
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subsys_private</span> *<span class="hljs-title">p</span>;</span>
	...
};
<span class="hljs-comment">/* /drivers/base/base.h */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subsys_private</span> {</span>
	...
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">klist</span> <span class="hljs-title">klist_devices</span>;</span>		<span class="hljs-comment">// i2c_client链(对于I2C总线来说)</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">klist</span> <span class="hljs-title">klist_drivers</span>;</span>		<span class="hljs-comment">// i2c_driver链(对于I2C总线来说)</span>
	...
};
<span class="hljs-comment">/* /include/linux/device/bus.c */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bus_register</span><span class="hljs-params">(struct bus_type *bus)</span>
</span>{
	...
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subsys_private</span> *<span class="hljs-title">priv</span>;</span>
	...
	klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);		<span class="hljs-comment">// 初始化i2c_client链</span>
	klist_init(&amp;priv-&gt;klist_drivers, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);	<span class="hljs-comment">// 初始化i2c_driver链</span>
	...
}
</div></code></pre>
<h2 id="42-注册i2c_adapter并将其添加到i2c总线">4.2. 注册i2c_adapter并将其添加到I2C总线</h2>
<p><code>i2c_adapter</code>在硬件上对应SoC的I2C控制器，在内核中被认为是一个设备，而其对应驱动即是总线驱动。它向接在I2C控制器上的I2C设备提供在I2C总线上通信的基础方法，通过操作SoC的I2C控制器相关的寄存器实现数据收发。</p>
<h3 id="421-注册i2c_adapter到platform总线">4.2.1. 注册i2c_adapter到platform总线</h3>
<p><code>i2c_adapter</code>一般通过两种方法注册：</p>
<ul>
<li>一种做法是为I2C适配器创建一个platform设备注册到<code>platform_bus_type</code>总线上与I2C适配器的platform驱动匹配，在驱动的probe函数中向I2C总线添加<code>i2c_adapter</code>和提供<code>i2c_algorithm</code>通信方法。</li>
<li>另一种做法是I2C适配器作为pci设备注册到PCI总线上与I2C适配器的pci驱动匹配，在驱动的probe函数中向i2c_bus_type添加<code>i2c_adapter</code>和提供<code>i2c_algorithm</code>通信方法。</li>
</ul>
<p>以TB-RK3568X为例，RK平台采用的是第一种方法。总线驱动的文件存储在路径<code>/drivers/i2c/busses</code>中，RK平台的总线驱动文件为<code>i2c-rk3x.c</code>。</p>
<p>结合<a href="#41-%E6%B3%A8%E5%86%8Ci2c%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E5%B1%82%E4%B8%BB%E8%A6%81%E6%98%AF%E6%B3%A8%E5%86%8Ci2c%E6%80%BB%E7%BA%BF">4.1</a>可知，编译进内核的驱动程序要在系统启动后为系统提供服务，则需事先将<code>init()</code>函数加入到内核的特定段中。驱动程序对应的<code>init()</code>函数是<code>module_init()</code>，对应放置的位置是内核中的<code>initcall6.init</code>段(据此，也可知内核是先注册总线，后注册驱动)。</p>
<p>为了提高代码的重用性，消除多余的样板文件。当module_init和module_exit都不做任何特殊操作时，调用宏定义函数 <code>module_platform_driver</code> 替换 <code>module_init</code> 和 <code>module_exit</code> (实际还要调用一次宏定义函数 <code>module_driver</code> 才能完成替换)。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /include/linux/platform_device.h */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> module_platform_driver(__platform_driver) \
</span>
    module_driver(__platform_driver, platform_driver_register, \
            platform_driver_unregister)
			
<span class="hljs-comment">/* /include/linux/device/driver.h */</span>
<span class="hljs-comment">/**
 * @__driver: driver name
 * @__register: register function for this driver type
 * @__unregister: unregister function for this driver type
 * @...: Additional arguments to be passed to __register and __unregister.
 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> module_driver(__driver, __register, __unregister, ...) \
static int __init __driver##_init(void) \
{ \
</span>
    <span class="hljs-keyword">return</span> __register(&amp;(__driver) , ##__VA_ARGS__); \

} \
module_init(__driver##_init); \
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __exit __driver##_exit(<span class="hljs-keyword">void</span>) \
{ \

    __unregister(&amp;(__driver) , ##__VA_ARGS__); \

} \
module_exit(__driver##_exit); 

<span class="hljs-comment">/* /drivers/i2c/busses/i2c-rk3x.c */</span>
module_platform_driver(rk3x_i2c_driver);	<span class="hljs-comment">// 注册i2c_adapter的platform_driver</span>
</div></code></pre>
<p><code>rk3x_i2c_driver</code>是一个<code>platform_driver</code>类型的结构体变量，重载了<code>*driver</code>结构体的部分变量(最重要的是匹配表<code>of_match_table</code>)和两个函数指针<code>probe()</code>和<code>remove()</code>。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/busses/i2c-rk3x.c */</span>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">rk3x_i2c_driver</span> =</span> {
	.probe   = rk3x_i2c_probe,
	.remove  = rk3x_i2c_remove,
	.driver  = {
		.name  = <span class="hljs-string">&quot;rk3x-i2c&quot;</span>,
		.of_match_table = rk3x_i2c_match,
		.pm = &amp;rk3x_i2c_pm_ops,
	},
};
</div></code></pre>
<p><code>module_init()</code>调用<code>platform_driver_register(rk3x_i2c_driver)</code>向platform总线注册总线驱动。后续流程匹配和调用收尾工作与I2C总线类似，就不做赘述。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/busses/i2c-rk3x.c */</span>
<span class="hljs-comment">/**
 * @param pdev: 即i2c_adapter，相当于是挂载在platform总线上的platform_device。
 */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rk3x_i2c_probe</span><span class="hljs-params">(struct platform_device *pdev)</span>
</span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span> =</span> pdev-&gt;dev.of_node;	<span class="hljs-comment">// i2c_adapter对应的设备节点</span>
    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *<span class="hljs-title">match</span>;</span>	<span class="hljs-comment">// 匹配表</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rk3x_i2c</span> *<span class="hljs-title">i2c</span>;</span>	<span class="hljs-comment">// 声明一个rk3x_i2c的适配器结构体，是i2c_adapter的进一步封装，相当于面向对象中的继承</span>
    ...
    <span class="hljs-comment">/**
     * 采用devm_kzalloc与kzalloc相比，优点在于不用考虑释放问题，由内核完成内存回收工作
     * devm_kzalloc — Resource-managed kzalloc
     * @param pdev: 申请内存的目标设备
     * @param gftp: 申请内存的类型标志，标识内存分配器将要采取的行为。其中GFP_KERNEL最常用，五内存可用时可引起休眠。
     * @return: 成功返回首地址，失败返回NULL
     * 为适配器结构体申请内存，为后续实例化完成基础工作。
     */</span>
    i2c = devm_kzalloc(&amp;pdev-&gt;dev, <span class="hljs-keyword">sizeof</span>(struct rk3x_i2c), GFP_KERNEL); 
    <span class="hljs-keyword">if</span> (!i2c)	<span class="hljs-comment">// 申请失败</span>
        <span class="hljs-keyword">return</span> -ENOMEM; 
	...
    <span class="hljs-comment">// i2c_adapter部分成员初始化</span>
    <span class="hljs-comment">// 名字</span>
    strlcpy(i2c-&gt;adap.name, <span class="hljs-string">&quot;rk3x-i2c&quot;</span>, <span class="hljs-keyword">sizeof</span>(i2c-&gt;adap.name));
    <span class="hljs-comment">// 拥有者</span>
    i2c-&gt;adap.owner = THIS_MODULE;
    <span class="hljs-comment">// 通信方法</span>
    i2c-&gt;adap.algo = &amp;rk3x_i2c_algorithm;
    i2c-&gt;adap.algo_data = i2c;
    i2c-&gt;adap.retries = <span class="hljs-number">3</span>;
    i2c-&gt;adap.dev.of_node = np;		
    i2c-&gt;adap.dev.parent = &amp;pdev-&gt;dev;
    i2c-&gt;dev = &amp;pdev-&gt;dev;
	...
    <span class="hljs-comment">// 向I2C总线添加i2c_adapter，重点</span>
    ret = i2c_add_adapter(&amp;i2c-&gt;adap);
    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">goto</span> err_clk_notifier;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	...
}
</div></code></pre>
<p>阅读注册收尾时被调用的<code>rk3x_i2c_probe()</code>函数源码可以知道，该函数负责将i2c_adapter和platform_device联系起来。并在对i2c_adapter各项参数进行配置后，将i2c_adapter添加到I2C总线。</p>
<p>参数配置中比较重要的是<code>rk3x_i2c_algorithm</code>，因为每家芯片厂商SoC内部的I2C控制器是不一样的，所以 <code>i2c_algorithm</code> 中直接涉及硬件层面上的代码都是由芯片商提供。例如：对I2C控制器的寄存器操作。 <code>i2c_algorithm</code> 提供的通信函数控制适配器产生特定的访问信号，虽然不同的I2C总线控制器被抽象成不同的 <code>i2c_adapter</code> ，但是如果操作方式相同，则可以共享同一个 <code>i2c_algorithm</code> 。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/busses/i2c-rk3x.c */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_algorithm</span> <span class="hljs-title">rk3x_i2c_algorithm</span> =</span> {
    .master_xfer		= rk3x_i2c_xfer,            <span class="hljs-comment">// 通信方法，如果不支持I2C访问，则为NULL</span>
    .master_xfer_atomic	= rk3x_i2c_xfer_polling,            <span class="hljs-comment">// 通信方法，在atomic context环境下使用。比如在关机之前、所有中断都关闭的情况下，用来访问电源管理芯片</span>
    .functionality		= rk3x_i2c_func,            <span class="hljs-comment">// 检测通信方法支持的功能或协议，设备驱动一般会调用这个回调来确认适配器支持的协议类型</span>
}; 
</div></code></pre>
<h3 id="422-将i2c_adapter添加到i2c总线">4.2.2. 将i2c_adapter添加到I2C总线</h3>
<p><a href="#421-%E6%B3%A8%E5%86%8Ci2c_adapter%E5%88%B0platform%E6%80%BB%E7%BA%BF">4.2.1</a>末尾提到：在<code>rk3x_i2c_probe()</code>的最后，调用了I2C核心层为总线驱动开放的添加适配器至I2C总线的接口函数<code>i2c_add_adapter()</code>。该函数的主要作用有两个：</p>
<ul>
<li>将对应的I2C总线的id分配给i2c_adapter。因为一个Soc内部通常会有多个I2C控制器，而所有I2C控制器实际都公用同一份总线驱动代码。</li>
<li>解析由i2c_adapter控制的每一个从设备，并构建出i2c_client。设备驱动加载运行需要i2c_client才能继续。</li>
</ul>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/i2c-core-base.c */</span>
<span class="hljs-comment">/**
 * i2c_add_adapter - declare i2c adapter, use dynamic bus number
 * @adapter: the adapter to add
 * Context: can sleep
 *
 * This routine is used to declare an I2C adapter when its bus number
 * doesn&#x27;t matter or when its bus number is specified by an dt alias.
 * Examples of bases when the bus number doesn&#x27;t matter: I2C adapters
 * dynamically added by USB links or PCI plugin cards.
 *
 * When this returns zero, a new bus number was allocated and stored
 * in adap-&gt;nr, and the specified adapter became available for clients.
 * Otherwise, a negative errno value is returned.
 */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">i2c_add_adapter</span><span class="hljs-params">(struct i2c_adapter *adapter)</span>
</span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">dev</span> =</span> &amp;adapter-&gt;dev;
	<span class="hljs-keyword">int</span> id;
    <span class="hljs-comment">// 对于在设备树定义的i2c适配器，则通过设备树获得总线号(在rk3x_i2c_probe中赋值dev-&gt;of_node)</span>
	<span class="hljs-keyword">if</span> (dev-&gt;of_node) {
        <span class="hljs-comment">// 获得总线号，因为总线驱动可以兼容多个同一平台的I2C控制器，一般会在dts里指定。</span>
		id = of_alias_get_id(dev-&gt;of_node, <span class="hljs-string">&quot;i2c&quot;</span>);
        <span class="hljs-comment">// 如果找到I2C总线号则直接注册</span>
		<span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span>) {
			adapter-&gt;nr = id;
			<span class="hljs-keyword">return</span> __i2c_add_numbered_adapter(adapter);	<span class="hljs-comment">// 添加已明确总线号的I2C适配器</span>
		}
	}
	mutex_lock(&amp;core_lock);
    <span class="hljs-comment">// 为i2c_adapter绑定动态总线号(从i2c_adapter_idr中申请一个可用的总线号)</span>
	id = idr_alloc(&amp;i2c_adapter_idr, adapter,
		       __i2c_first_dynamic_bus_num, <span class="hljs-number">0</span>, GFP_KERNEL);
	mutex_unlock(&amp;core_lock);
	<span class="hljs-keyword">if</span> (WARN(id &lt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;couldn&#x27;t get idr&quot;</span>))
		<span class="hljs-keyword">return</span> id;
	adapter-&gt;nr = id;
	<span class="hljs-keyword">return</span> i2c_register_adapter(adapter);	<span class="hljs-comment">// 在I2C总线上注册i2c_adapter</span>
}
</div></code></pre>
<p>在设备树中有一个叫做aliases的节点，在Linux内核启动的时候，会按如下流程解析这个节点，将节点内的信息加入到全局<code>aliases_lookup</code>链表中。</p>
<pre>
start_kernel
	--> setup_arch
		--> unflatten_device_tree
			--> of_alias_scan
				--> of_alias_add
</pre>
<p><code>i2c_add_adapter()</code>提供了两种为i2c_adapter分配id的方法。对于在设备树定义的i2c_adapter，调用<code>of_alias_get_id()</code>遍历<code>aliases_lookup</code>链表获得明确的I2C总线号，并调用<code>__i2c_add_numbered_adapter()</code>函数添加i2c_adapter。否则，从i2c_adapter_idr中申请一个可用的总线号供i2c_adapter添加。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/of/base.c */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">of_alias_get_id</span><span class="hljs-params">(struct device_node *np, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *stem)</span>
</span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">alias_prop</span> *<span class="hljs-title">app</span>;</span>
	<span class="hljs-keyword">int</span> id = -ENODEV;
	mutex_lock(&amp;of_mutex);
    <span class="hljs-comment">// 遍历链表aliases_lookup(成员为alias_prop)，逐一对比字符串stem。</span>
	list_for_each_entry(app, &amp;aliases_lookup, link) {
        <span class="hljs-comment">// 过滤掉dtsi中aliases节点内的非I2C节点</span>
		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(app-&gt;stem, stem) != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">continue</span>;
        <span class="hljs-comment">// 如果字符串匹配且找到对应的device_node，则说明获得ID</span>
		<span class="hljs-keyword">if</span> (np == app-&gt;np) {
			id = app-&gt;id;
			<span class="hljs-keyword">break</span>;
		}
	}
	mutex_unlock(&amp;of_mutex);
	<span class="hljs-keyword">return</span> id;
}
</div></code></pre>
<p>无论i2c_adapter是如何获得id的，其最终都是调用<code>i2c_register_adapter</code>在I2C总线上注册i2c_adapter。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/i2c-core-base.c */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">i2c_register_adapter</span><span class="hljs-params">(struct i2c_adapter *adap)</span>
</span>{
	...
	<span class="hljs-comment">/* 如果adapter没有name和algo算法，则无法注册 */</span>
	<span class="hljs-keyword">if</span> (WARN(!adap-&gt;name[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;i2c adapter has no name&quot;</span>))
		<span class="hljs-keyword">goto</span> out_list;
	<span class="hljs-keyword">if</span> (!adap-&gt;algo) {
		pr_err(<span class="hljs-string">&quot;adapter &#x27;%s&#x27;: no algo supplied!\n&quot;</span>, adap-&gt;name);
		<span class="hljs-keyword">goto</span> out_list;
	}
	...
	<span class="hljs-comment">// 注册到I2C总线</span>
	dev_set_name(&amp;adap-&gt;dev, <span class="hljs-string">&quot;i2c-%d&quot;</span>, adap-&gt;nr);
	adap-&gt;dev.bus = &amp;i2c_bus_type;
	adap-&gt;dev.type = &amp;i2c_adapter_type;

	res = device_register(&amp;adap-&gt;dev);	<span class="hljs-comment">// 将adapter设备添加到I2C总线，生成i2c_client。</span>
	<span class="hljs-keyword">if</span> (res) {
		pr_err(<span class="hljs-string">&quot;adapter &#x27;%s&#x27;: can&#x27;t register device (%d)\n&quot;</span>, adap-&gt;name, res);
		<span class="hljs-keyword">goto</span> out_list;
	}
	...
	<span class="hljs-comment">/* create pre-declared device nodes */</span>
    <span class="hljs-comment">// 构建从设备的软件抽象i2c_client，并与adapter建立联系</span>
	of_i2c_register_devices(adap);
	...
	<span class="hljs-keyword">if</span> (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)
		i2c_scan_static_board_info(adap);
	<span class="hljs-comment">/* Notify drivers */</span>
	mutex_lock(&amp;core_lock);
	bus_for_each_drv(&amp;i2c_bus_type, <span class="hljs-literal">NULL</span>, adap, __process_new_adapter);		<span class="hljs-comment">// 匹配机制。遍历整个driver链表，进行i2c_client与i2c_driver的匹配工作</span>
	mutex_unlock(&amp;core_lock);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	...
out_list:
	...
}
</div></code></pre>
<p><code>i2c_register_adapter()</code>函数最重要的作用是解析由i2c_adapter控制的每一个从设备，并构建出i2c_client。进而完成i2c_driver和i2c_client的匹配。前者由函数<code>of_i2c_register_devices()</code>负责，后者依靠函数<code>bus_for_each_drv()</code>调用<code>i2c_detect()</code>，寻找I2C总线支持的设备实现。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/i2c-core-of.c */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">of_i2c_register_devices</span><span class="hljs-params">(struct i2c_adapter *adap)</span>
</span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">bus</span>, *<span class="hljs-title">node</span>;</span>
    <span class="hljs-comment">// 构建i2c_client</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span>;</span>
	<span class="hljs-comment">/* Only register child devices if the adapter has a node pointer set */</span>
	<span class="hljs-keyword">if</span> (!adap-&gt;dev.of_node)
		<span class="hljs-keyword">return</span>;
	dev_dbg(&amp;adap-&gt;dev, <span class="hljs-string">&quot;of_i2c: walking child nodes\n&quot;</span>);
    <span class="hljs-comment">// 查找设备树节点中名称有直接描述I2C总线的节点，缩小查找范围</span>
	bus = of_get_child_by_name(adap-&gt;dev.of_node, <span class="hljs-string">&quot;i2c-bus&quot;</span>);
    <span class="hljs-comment">// 没找到则从头开始遍历</span>
	<span class="hljs-keyword">if</span> (!bus)
		bus = of_node_get(adap-&gt;dev.of_node);
    <span class="hljs-comment">// 遍历每一个子节点，调用of_i2c_register_device解析设备树节点内容并注册为i2c_client</span>
	for_each_available_child_of_node(bus, node) {
		<span class="hljs-keyword">if</span> (of_node_test_and_set_flag(node, OF_POPULATED))
			<span class="hljs-keyword">continue</span>;

		client = of_i2c_register_device(adap, node);
		<span class="hljs-keyword">if</span> (IS_ERR(client)) {
			dev_err(&amp;adap-&gt;dev,
				 <span class="hljs-string">&quot;Failed to create I2C device for %pOF\n&quot;</span>,
				 node);
			of_node_clear_flag(node, OF_POPULATED);
		}
	}
	of_node_put(bus);
}
</div></code></pre>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/i2c-core-of.c */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> struct i2c_client *<span class="hljs-title">of_i2c_register_device</span><span class="hljs-params">(struct i2c_adapter *adap, 
						 						 struct device_node *node)</span>
</span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span> *<span class="hljs-title">client</span>;</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_board_info</span> <span class="hljs-title">info</span>;</span>
	<span class="hljs-keyword">int</span> ret;
	dev_dbg(&amp;adap-&gt;dev, <span class="hljs-string">&quot;of_i2c: register %pOF\n&quot;</span>, node);
	ret = of_i2c_get_board_info(&amp;adap-&gt;dev, node, &amp;info);
	<span class="hljs-keyword">if</span> (ret)
		<span class="hljs-keyword">return</span> ERR_PTR(ret);
	client = i2c_new_client_device(adap, &amp;info);
	<span class="hljs-keyword">if</span> (IS_ERR(client))
		dev_err(&amp;adap-&gt;dev, <span class="hljs-string">&quot;of_i2c: Failure registering %pOF\n&quot;</span>, node);
	<span class="hljs-keyword">return</span> client;
}
</div></code></pre>
<p>在构建i2c_client的过程中，需要读取设备树信息赋值给对应的i2c_device。这个操作由<code>of_i2c_get_board_info()</code>函数完成。例如：调用<code>of_modalias_node()</code>函数获得<code>client-&gt;name</code>。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/i2c-core-of.c */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">of_i2c_get_board_info</span><span class="hljs-params">(struct device *dev, struct device_node *node,
			  			  struct i2c_board_info *info)</span>
</span>{
	u32 addr;
	<span class="hljs-keyword">int</span> ret;
	<span class="hljs-built_in">memset</span>(info, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(*info));
	<span class="hljs-keyword">if</span> (of_modalias_node(node, info-&gt;type, <span class="hljs-keyword">sizeof</span>(info-&gt;type)) &lt; <span class="hljs-number">0</span>) {
		dev_err(dev, <span class="hljs-string">&quot;of_i2c: modalias failure on %pOF\n&quot;</span>, node);
		<span class="hljs-keyword">return</span> -EINVAL;
	}
		ret = of_property_read_u32(node, <span class="hljs-string">&quot;reg&quot;</span>, &amp;addr); <span class="hljs-comment">// 对应设备树中的&lt;reg&gt;标签</span>
	<span class="hljs-keyword">if</span> (ret) {
		dev_err(dev, <span class="hljs-string">&quot;of_i2c: invalid reg on %pOF\n&quot;</span>, node);
		<span class="hljs-keyword">return</span> ret;
	}
	<span class="hljs-keyword">if</span> (addr &amp; I2C_TEN_BIT_ADDRESS) {
		addr &amp;= ~I2C_TEN_BIT_ADDRESS;
		info-&gt;flags |= I2C_CLIENT_TEN;
	}
	<span class="hljs-keyword">if</span> (addr &amp; I2C_OWN_SLAVE_ADDRESS) {
		addr &amp;= ~I2C_OWN_SLAVE_ADDRESS;
		info-&gt;flags |= I2C_CLIENT_SLAVE;
	}
	info-&gt;addr = addr;
	info-&gt;of_node = node;
	info-&gt;fwnode = of_fwnode_handle(node);
	<span class="hljs-keyword">if</span> (of_property_read_bool(node, <span class="hljs-string">&quot;host-notify&quot;</span>))
		info-&gt;flags |= I2C_CLIENT_HOST_NOTIFY;
	<span class="hljs-keyword">if</span> (of_get_property(node, <span class="hljs-string">&quot;wakeup-source&quot;</span>, <span class="hljs-literal">NULL</span>))
		info-&gt;flags |= I2C_CLIENT_WAKE;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/of/base.c */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">of_modalias_node</span><span class="hljs-params">(struct device_node *node, <span class="hljs-keyword">char</span> *modalias, <span class="hljs-keyword">int</span> len)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *compatible, *p;
	<span class="hljs-keyword">int</span> cplen;

	compatible = of_get_property(node, <span class="hljs-string">&quot;compatible&quot;</span>, &amp;cplen);	<span class="hljs-comment">// 查找&quot;compatible&quot;属性</span>
	<span class="hljs-keyword">if</span> (!compatible || <span class="hljs-built_in">strlen</span>(compatible) &gt; cplen)
		<span class="hljs-keyword">return</span> -ENODEV;
	p = <span class="hljs-built_in">strchr</span>(compatible, <span class="hljs-string">&#x27;,&#x27;</span>);	<span class="hljs-comment">// 定位，&quot;manufacturer, model&quot;</span>
	strlcpy(modalias, p ? p + <span class="hljs-number">1</span> : compatible, len);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>最终由<code>i2c_new_client_device()</code>函数调用的<code>i2c_new_client_device()</code>根据获得的<code>info</code>完成i2c_client的构建。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/i2c-core-base.c */</span>
<span class="hljs-function">struct i2c_client *<span class="hljs-title">i2c_new_client_device</span><span class="hljs-params">(struct i2c_adapter *adap, 
										 struct i2c_board_info <span class="hljs-keyword">const</span> *info)</span>
</span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_client</span>	*<span class="hljs-title">client</span>;</span>
	<span class="hljs-keyword">int</span>			status;
	client = kzalloc(<span class="hljs-keyword">sizeof</span> *client, GFP_KERNEL);	<span class="hljs-comment">// 分配内核空间</span>
	<span class="hljs-keyword">if</span> (!client)
		<span class="hljs-keyword">return</span> ERR_PTR(-ENOMEM);
	<span class="hljs-comment">// 配置client的基本信息</span>
	client-&gt;adapter = adap;
	client-&gt;dev.platform_data = info-&gt;platform_data;
	client-&gt;flags = info-&gt;flags;
	client-&gt;addr = info-&gt;addr		<span class="hljs-comment">// 对应设备树中的&lt;reg&gt;标签</span>
	client-&gt;init_irq = info-&gt;irq;
	<span class="hljs-keyword">if</span> (!client-&gt;init_irq)
		client-&gt;init_irq = i2c_dev_irq_from_resources(info-&gt;resources,
							 						  info-&gt;num_resources);
	strlcpy(client-&gt;name, info-&gt;type, <span class="hljs-keyword">sizeof</span>(client-&gt;name));
	status = i2c_check_addr_validity(client-&gt;addr, client-&gt;flags);
	<span class="hljs-keyword">if</span> (status) {
		dev_err(&amp;adap-&gt;dev, <span class="hljs-string">&quot;Invalid %d-bit I2C address 0x%02hx\n&quot;</span>,
				client-&gt;flags &amp; I2C_CLIENT_TEN ? <span class="hljs-number">10</span> : <span class="hljs-number">7</span>, client-&gt;addr);
		<span class="hljs-keyword">goto</span> out_err_silent;
	}
	<span class="hljs-comment">/* Check for address business */</span>
	status = i2c_check_addr_ex(adap, i2c_encode_flags_to_addr(client));
	<span class="hljs-keyword">if</span> (status)
		dev_err(&amp;adap-&gt;dev,
				<span class="hljs-string">&quot;%d i2c clients have been registered at 0x%02x&quot;</span>,
				status, client-&gt;addr);
	client-&gt;dev.parent = &amp;client-&gt;adapter-&gt;dev;
	client-&gt;dev.bus = &amp;i2c_bus_type;
	client-&gt;dev.type = &amp;i2c_client_type;
	client-&gt;dev.of_node = of_node_get(info-&gt;of_node);
	client-&gt;dev.fwnode = info-&gt;fwnode;
	i2c_dev_set_name(adap, client, info, status);
	<span class="hljs-keyword">if</span> (info-&gt;properties) {
		status = device_add_properties(&amp;client-&gt;dev, info-&gt;properties);
		<span class="hljs-keyword">if</span> (status) {
			dev_err(&amp;adap-&gt;dev,
					<span class="hljs-string">&quot;Failed to add properties to client %s: %d\n&quot;</span>,
					client-&gt;name, status);
			<span class="hljs-keyword">goto</span> out_err_put_of_node;
		}
	}
	status = device_register(&amp;client-&gt;dev);
	<span class="hljs-keyword">if</span> (status)
		<span class="hljs-keyword">goto</span> out_free_props;
	dev_dbg(&amp;adap-&gt;dev, <span class="hljs-string">&quot;client [%s] registered with bus id %s\n&quot;</span>,
			client-&gt;name, dev_name(&amp;client-&gt;dev));
	<span class="hljs-keyword">return</span> client;
out_free_props:
	...
out_err_put_of_node:
	...
out_err_silent:
	...

}
</div></code></pre>
<h3 id="423-总结">4.2.3. 总结</h3>
<p>整个过程调用关系如下：</p>
<pre>
rk3x_i2c_probe
	--> i2c_add_adapter
		--> __i2c_add_numbered_adapter
			--> i2c_register_adapter
				--> of_i2c_register_devices
					--> of_i2c_register_device
						--> of_i2c_get_board_info
							--> of_modalias_node
					--> i2c_new_client_device
				--> bus_for_each_drv
					--> __process_new_adapter
						--> i2c_do_add_adapter
							--> i2c_detect
</pre>
<h2 id="43-i2c设备驱动开发">4.3. I2C设备驱动开发</h2>
<p>完成I2C总线注册和i2c_adapter的注册后，就可以进行I2C设备驱动的开发了。由I2C驱动框架图可知，实现I2C设备驱动通常有两条路径：</p>
<h3 id="431-将i2c控制器暴露给应用的方式">4.3.1. 将I2C控制器暴露给应用的方式</h3>
<p>该方式采用标准的 <code>file_operations</code> 字符设备的形式，将 <code>i2c_adapter</code> 设备化，在<code>/dev</code>目录下创建<code>i2c-n(n=0, 1, 2...)</code>设备节点。所实现的驱动可看作是一种&quot; <code>i2c_driver</code> 成员函数 + 字符设备驱动&quot;的虚拟驱动，需要由应用层通过 <code>read()</code> 、 <code>write()</code> 函数根据芯片手册直接对I2C控制器进行配置时序等操作，以实现对从设备的控制。这种方式是把对硬件的具体操作放在应用层去实现，适合用来快速测试一款I2C设备的功能，或者在 <code>i2c_driver</code> 工作不正常的时候排查具体是设备驱动工作问题还是主机驱动工作问题。并不能作为主流的开发方式。</p>
<p>驱动开发流程中的初始化、注册等准备流程工作和上文描述原理相同，不再赘述。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* //drivers/i2c/i2c-dev.c */</span>
<span class="hljs-comment">//设备节点的操作方法</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">i2cdev_fops</span> =</span> {
	.owner		= THIS_MODULE,
	.llseek		= no_llseek,
	.read		= i2cdev_read,
	.write		= i2cdev_write,
	.unlocked_ioctl	= i2cdev_ioctl,
	.open		= i2cdev_open,
	.release	= i2cdev_release,
};

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> I2C_MAJOR	89		<span class="hljs-comment">/* Device major number		*/</span></span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init <span class="hljs-title">i2c_dev_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">int</span> res;

	printk(KERN_INFO <span class="hljs-string">&quot;i2c /dev entries driver\n&quot;</span>);
	<span class="hljs-comment">// 申请设备号，I2C_MAJOR为89，次设备号为0，I2C_MINORS为1&lt;&lt;20-1，表示次设备号的数量。</span>
	<span class="hljs-comment">// 就是把这个主设备号对应的次设备号都申请了。</span>
	res = register_chrdev_region(MKDEV(I2C_MAJOR, <span class="hljs-number">0</span>), I2C_MINORS, <span class="hljs-string">&quot;i2c&quot;</span>);
	<span class="hljs-keyword">if</span> (res)
		<span class="hljs-keyword">goto</span> out;
	<span class="hljs-comment">// 创建一个同名类，在 /sys/class中可以看到</span>
	i2c_dev_class = class_create(THIS_MODULE, <span class="hljs-string">&quot;i2c-dev&quot;</span>);
	<span class="hljs-keyword">if</span> (IS_ERR(i2c_dev_class)) {
		res = PTR_ERR(i2c_dev_class);
		<span class="hljs-keyword">goto</span> out_unreg_chrdev;
	}
	i2c_dev_class-&gt;dev_groups = i2c_groups;

	<span class="hljs-comment">/* Keep track of adapters which will be added or removed later */</span>
	<span class="hljs-comment">// 注册i2c总线的通知函数</span>
	<span class="hljs-comment">// 参数2详见下</span>
	res = bus_register_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);
	<span class="hljs-keyword">if</span> (res)
		<span class="hljs-keyword">goto</span> out_unreg_class;

	<span class="hljs-comment">/* Bind to already existing adapters right away */</span>
	<span class="hljs-comment">// 遍历i2c总线上的所有设备，每次都执行第二个参数对应的函数</span>
	i2c_for_each_dev(<span class="hljs-literal">NULL</span>, i2cdev_attach_adapter);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

out_unreg_class:
	class_destroy(i2c_dev_class);
out_unreg_chrdev:
	unregister_chrdev_region(MKDEV(I2C_MAJOR, <span class="hljs-number">0</span>), I2C_MINORS);
out:
	printk(KERN_ERR <span class="hljs-string">&quot;%s: Driver Initialisation failed\n&quot;</span>, __FILE__);
	<span class="hljs-keyword">return</span> res;
}
</div></code></pre>
<p>设备节点是在驱动注册的过程中创建的，调用关系如下：</p>
<pre>
i2c_dev_init()
	i2c_for_each_dev()
		bus_for_each_dev()
			i2cdev_attach_adapter()
				device_create()
				device_create_file()
</pre>
<pre><code class="language-C"><div>
`i2cdev_attach_adapter()`函数调用`device_create()`函数和`device_create_file()`函数完成了设备节点的创建。

<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">i2cdev_attach_adapter</span><span class="hljs-params">(struct i2c_adapter *adap)</span>
</span>{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_dev</span> *<span class="hljs-title">i2c_dev</span>;</span>
	<span class="hljs-keyword">int</span> res;

	<span class="hljs-comment">//分配一个i2c_dev对象，并添加到i2c_dev_list链表中</span>
	i2c_dev = get_free_i2c_dev(adap);
	<span class="hljs-keyword">if</span> (IS_ERR(i2c_dev))
		<span class="hljs-keyword">return</span> PTR_ERR(i2c_dev);

	<span class="hljs-comment">/* 创建设备对象并在sysfs中注册，在/dev目录下创建设备号为MKDEV(I2C_MAJOR, adap-&gt;nr)，
		名称为&quot;i2c-%d&quot;的字符设备节点*/</span>
	i2c_dev-&gt;dev = device_create(i2c_dev_class, &amp;adap-&gt;dev,
				     MKDEV(I2C_MAJOR, adap-&gt;nr), <span class="hljs-literal">NULL</span>,
				     <span class="hljs-string">&quot;i2c-%d&quot;</span>, adap-&gt;nr);
	<span class="hljs-keyword">if</span> (IS_ERR(i2c_dev-&gt;dev)) {
		res = PTR_ERR(i2c_dev-&gt;dev);
		<span class="hljs-keyword">goto</span> error;
	}

	<span class="hljs-comment">//创建&quot;/sys/class/i2c-dev/&quot;i2c-%d&quot;/name&quot;文件</span>
	res = device_create_file(i2c_dev-&gt;dev, &amp;dev_attr_name);
	<span class="hljs-keyword">if</span> (res)
		<span class="hljs-keyword">goto</span> error_destroy;

	pr_debug(<span class="hljs-string">&quot;i2c-dev: adapter [%s] registered as minor %d\n&quot;</span>,
		 adap-&gt;name, adap-&gt;nr);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
error_destroy:
	device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, adap-&gt;nr));
error:
	return_i2c_dev(i2c_dev);
	<span class="hljs-keyword">return</span> res;
}
</div></code></pre>
<p>完成i2c设备驱动的注册后，就可以通过<code>i2cdev_fops</code>中提供的各项功能与I2C设备进行交互。</p>
<h3 id="432-将i2c控制器抽象成公共驱动的方式">4.3.2. 将I2C控制器抽象成公共驱动的方式</h3>
<p>该方式是把所有代码都放在驱动层实现，直接向应用层提供最终结果，即应用层甚至可以不知道I2C的存在。例如电容式触摸屏驱动直接向应用层提供 <code>/dev/input/eventn</code> 的操作接口，接收上报到应用层的输入事件。而不需要直到具体是怎么上报的，甚至应用层不知道触摸屏是使用I2C总线和主机进行数据交互的。</p>
<p>以汇顶科技的gt1x型电容式触摸屏为例，电容触摸屏通过I2C总线与SoC进行通信，利用其自带的触摸IC完成坐标计算后通过I2C将坐标信息传输给SoC，坐标的计算过程不需要SoC的参与。从这个角度上来说，电容触摸屏就是一个挂载到SoC上的I2C从设备。触摸屏内I2C相关的功能函数<code>gt1x_i2c_write()</code>和<code>gt1x_i2c_read()</code>都被封装到<code>gt1x_ts_work_func()</code>中，具体可阅读位于<code>/driver/input/touchscreen/gt1x/</code>的源码<code>gt1x.c</code>。</p>
<h2 id="44-重点分析">4.4. 重点分析</h2>
<h3 id="441-何时调用match函数何时调用probe函数">4.4.1. 何时调用match()函数？何时调用probe()函数？</h3>
<p>要搞清楚<code>match()</code>和<code>probe()</code>函数是何时被何者所调用的，需对源码进行深入了解。根据文档描述，<code>probe()</code>函数执行于<code>match()</code>函数之后，且匹配触发的前提是要有i2c_driver或者i2c_client注册到I2C总线。所以尝试从i2c_driver的注册代码中寻找答案。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/i2c-core-base.c */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">i2c_register_driver</span><span class="hljs-params">(struct <span class="hljs-keyword">module</span> *owner, struct i2c_driver *driver)</span>
</span>{
	...
	driver-&gt;driver.bus = &amp;i2c_bus_type;
	INIT_LIST_HEAD(&amp;driver-&gt;clients);
	...
	<span class="hljs-comment">/* When registration returns, the driver core
	 * will have called probe() for all matching-but-unbound devices.
	 */</span>
	res = driver_register(&amp;driver-&gt;driver);     <span class="hljs-comment">// 实际注册位置</span>
	<span class="hljs-keyword">if</span> (res)
		<span class="hljs-keyword">return</span> res;
    ...
}
</div></code></pre>
<p>注意到<code>i2c_register_driver</code>函数中实际是调用了<code>driver_register()</code>函数完成注册，并且根据注释描述，正是在<code>driver_register()</code>中完成了<code>match()</code>和<code>probe()</code>的工作。因此继续进入<code>driver_register()</code>函数中进行跟踪。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/base/driver.c */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">driver_register</span><span class="hljs-params">(struct device_driver *drv)</span>
</span>{
	...
	ret = bus_add_driver(drv);              <span class="hljs-comment">// 在总线上添加传递的驱动(将驱动添加到总线的驱动链表中)</span>
	...
}
</div></code></pre>
<p><code>driver_register()</code>函数中调用了<code>bus_add_driver()</code>函数，将驱动添加到总线上，继续深入直到找到有关<code>match</code>和<code>probe</code>的函数。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/base/bus.c */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bus_add_driver</span><span class="hljs-params">(struct device_driver *drv)</span>
</span>{
	...
	<span class="hljs-keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe)
    {
		error = driver_attach(drv);         <span class="hljs-comment">// 跟踪driver_attach();</span>
		<span class="hljs-keyword">if</span> (error)
			<span class="hljs-keyword">goto</span> out_unregister;
	}
	...
}
</div></code></pre>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/base/dd.c */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">driver_attach</span><span class="hljs-params">(struct device_driver *drv)</span>
</span>{
	<span class="hljs-keyword">return</span> bus_for_each_dev(drv-&gt;bus, <span class="hljs-literal">NULL</span>, drv, __driver_attach);  <span class="hljs-comment">// 实际是在调用__driver_attach();</span>
}
</div></code></pre>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/base/bus.c */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bus_for_each_dev</span><span class="hljs-params">(struct bus_type *bus, struct device *start,
		     		 <span class="hljs-keyword">void</span> *data, <span class="hljs-keyword">int</span> (*fn)(struct device *, <span class="hljs-keyword">void</span> *))</span>
</span>{
	...
	klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_devices, &amp;i,
			     (start ? &amp;start-&gt;p-&gt;knode_bus : <span class="hljs-literal">NULL</span>));	<span class="hljs-comment">// 	链表头开始遍历连接在总线上的设备链表</span>
	<span class="hljs-keyword">while</span> (!error &amp;&amp; (dev = next_device(&amp;i)))
		error = fn(dev, data);
	klist_iter_exit(&amp;i);
	<span class="hljs-keyword">return</span> error;
}
</div></code></pre>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/base/dd.c */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __driver_attach(struct device *dev, <span class="hljs-keyword">void</span> *data)
{
	...
	ret = driver_match_device(drv, dev);        <span class="hljs-comment">// 驱动和设备匹配</span>
	<span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) {
		<span class="hljs-comment">/* no match */</span>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == -EPROBE_DEFER) {
		dev_dbg(dev, <span class="hljs-string">&quot;Device match requests probe deferral\n&quot;</span>);
		driver_deferred_probe_add(dev);
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) {
		dev_dbg(dev, <span class="hljs-string">&quot;Bus failed to match device: %d\n&quot;</span>, ret);
		<span class="hljs-keyword">return</span> ret;
	} <span class="hljs-comment">/* ret &gt; 0 means positive match */</span>

	......

    device_driver_attach(drv, dev);
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/base/base.h */</span> 
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">driver_match_device</span><span class="hljs-params">(struct device_driver *drv,
				      struct device *dev)</span>
</span>{
	<span class="hljs-keyword">return</span> drv-&gt;bus-&gt;match ? drv-&gt;bus-&gt;match(dev, drv) : <span class="hljs-number">1</span>;
}
</div></code></pre>
<p>至此，可知是<code>driver_match_device</code>函数调用了I2C总线的<code>i2c_device_match()</code>函数完成对驱动和设备的匹配工作。而匹配完成后<code>probe()</code>的调用则还需跟踪进<code>device_driver_attach</code>函数分析。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/base/dd.c */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">device_driver_attach</span><span class="hljs-params">(struct device_driver *drv, struct device *dev)</span>
</span>{
	<span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
	__device_driver_lock(dev, dev-&gt;parent);
	<span class="hljs-comment">/*
	 * If device has been removed or someone has already successfully
	 * bound a driver before us just skip the driver probe call.
	 */</span>
	<span class="hljs-keyword">if</span> (!dev-&gt;p-&gt;dead &amp;&amp; !dev-&gt;driver)
		ret = driver_probe_device(drv, dev);
	__device_driver_unlock(dev, dev-&gt;parent);
	<span class="hljs-keyword">return</span> ret;
}
</div></code></pre>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/base/dd.c */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">driver_probe_device</span><span class="hljs-params">(struct device_driver *drv, struct device *dev)</span>
</span>{
    ...
	pm_runtime_barrier(dev);
	<span class="hljs-keyword">if</span> (initcall_debug)
		ret = really_probe_debug(dev, drv);
	<span class="hljs-keyword">else</span>
		ret = really_probe(dev, drv);
	...
}
</div></code></pre>
<p>在<code>really_probe()</code>函数中，调用了总线的<code>probe()</code>函数，以I2C为例就是<code>i2c_device_probe()</code>。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/base/dd.c */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">really_probe</span><span class="hljs-params">(struct device *dev, struct device_driver *drv)</span>
</span>{
	...
	<span class="hljs-keyword">if</span> (dev-&gt;bus-&gt;probe) {
		ret = dev-&gt;bus-&gt;probe(dev);
		<span class="hljs-keyword">if</span> (ret)
			<span class="hljs-keyword">goto</span> probe_failed;
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (drv-&gt;probe) {
		ret = drv-&gt;probe(dev);
		<span class="hljs-keyword">if</span> (ret)
			<span class="hljs-keyword">goto</span> probe_failed;
	}
    ...
}
</div></code></pre>
<p><code>i2c_device_probe()</code>函数中，通过<code>driver-&gt;probe()</code>调用定义的i2c_driver的<code>probe()</code>函数。以gt1x型电容式触摸屏的驱动为例，则是<code>gt1x_ts_probe()</code>。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/i2c-core-base.c */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">i2c_device_probe</span><span class="hljs-params">(struct device *dev)</span>
</span>{
	...
	<span class="hljs-comment">/*
	 * When there are no more users of probe(),
	 * rename probe_new to probe.
	 */</span>
	<span class="hljs-keyword">if</span> (driver-&gt;probe_new)
		status = driver-&gt;probe_new(client);
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (driver-&gt;probe)
		status = driver-&gt;probe(client,
				       i2c_match_id(driver-&gt;id_table, client));
	<span class="hljs-keyword">else</span>
		status = -EINVAL;
	...
}

</div></code></pre>
<p>整体流程如下：</p>
<center>
<img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/%E4%BD%95%E6%97%B6%E8%B0%83%E7%94%A8match%E5%87%BD%E6%95%B0%E5%92%8Cprobe%E5%87%BD%E6%95%B0.png?raw=true" width="55%" />
</center>
<h3 id="442-设备树匹配机制">4.4.2. 设备树匹配机制</h3>
<p><a href="#41-%E6%B3%A8%E5%86%8Ci2c%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E5%B1%82%E4%B8%BB%E8%A6%81%E6%98%AF%E6%B3%A8%E5%86%8Ci2c%E6%80%BB%E7%BA%BF">4.1</a>节中便讨论过<code>i2c_device_match()</code>提供了三种匹配方式，并简单介绍了使用注册时配置的<code>id_table</code>进行匹配的方法。下面主要讨论设备树匹配方式。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/i2c/i2c-core-of.c */</span>
<span class="hljs-function"><span class="hljs-keyword">const</span> struct of_device_id*
<span class="hljs-title">i2c_of_match_device</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct of_device_id *matches,
		     		struct i2c_client *client)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *<span class="hljs-title">match</span>;</span>

	<span class="hljs-keyword">if</span> (!(client &amp;&amp; matches))
		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;

	match = of_match_device(matches, &amp;client-&gt;dev);		<span class="hljs-comment">// 进行匹配</span>
	<span class="hljs-keyword">if</span> (match)											<span class="hljs-comment">// 一次匹配成功</span>
		<span class="hljs-keyword">return</span> match;

	<span class="hljs-keyword">return</span> i2c_of_match_device_sysfs(matches, client);	<span class="hljs-comment">// 与I2C MUX(I2C多路复用器有关)，内核将MUX通道抽象为逻辑I2C总线号，由Linux I2C Sysfs管理。</span>
}

</div></code></pre>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/of/device.c */</span>
<span class="hljs-function"><span class="hljs-keyword">const</span> struct of_device_id *<span class="hljs-title">of_match_device</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct of_device_id *matches,
					   <span class="hljs-keyword">const</span> struct device *dev)</span>
</span>{
	<span class="hljs-keyword">if</span> ((!matches) || (!dev-&gt;of_node))
		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">return</span> of_match_node(matches, dev-&gt;of_node);
}
</div></code></pre>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/of/base.c */</span>
<span class="hljs-function"><span class="hljs-keyword">const</span> struct of_device_id *<span class="hljs-title">of_match_node</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct of_device_id *matches,
					 <span class="hljs-keyword">const</span> struct device_node *node)</span>
</span>{
	...
	match = __of_match_node(matches, node);
	...
	<span class="hljs-keyword">return</span> match;
}
</div></code></pre>
<p><code>__of_match_node()</code>函数是设备树匹配的核心部分——通过得分机制，寻找最佳匹配。</p>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/of/base.c */</span>
<span class="hljs-keyword">static</span>
<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *__<span class="hljs-title">of_match_node</span>(<span class="hljs-title">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *<span class="hljs-title">matches</span>,
					   <span class="hljs-title">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">node</span>)
{</span>
	<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> *<span class="hljs-title">best_match</span> =</span> <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">int</span> score, best_score = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span> (!matches)
		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
	<span class="hljs-comment">// 根据评分来选取最佳匹配</span>
	<span class="hljs-keyword">for</span> (; matches-&gt;name[<span class="hljs-number">0</span>] || matches-&gt;type[<span class="hljs-number">0</span>] || matches-&gt;compatible[<span class="hljs-number">0</span>]; matches++) {
		score = __of_device_is_compatible(node, matches-&gt;compatible,
						  matches-&gt;type, matches-&gt;name);
		<span class="hljs-keyword">if</span> (score &gt; best_score) {
			best_match = matches;
			best_score = score;
		}
	}
	<span class="hljs-keyword">return</span> best_match;
}
</div></code></pre>
<pre><code class="language-C"><div><span class="hljs-comment">/* /drivers/of/base.c */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __of_device_is_compatible(<span class="hljs-keyword">const</span> struct device_node *device,
				     <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *compat, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *type, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name)
{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">property</span> *<span class="hljs-title">prop</span>;</span>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cp;
	<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>, score = <span class="hljs-number">0</span>;
	<span class="hljs-comment">/* Compatible match has highest priority */</span>
	<span class="hljs-keyword">if</span> (compat &amp;&amp; compat[<span class="hljs-number">0</span>]) {
		prop = __of_find_property(device, <span class="hljs-string">&quot;compatible&quot;</span>, <span class="hljs-literal">NULL</span>);
		<span class="hljs-keyword">for</span> (cp = of_prop_next_string(prop, <span class="hljs-literal">NULL</span>); cp;
		     cp = of_prop_next_string(prop, cp), index++) {
			<span class="hljs-keyword">if</span> (of_compat_cmp(cp, compat, <span class="hljs-built_in">strlen</span>(compat)) == <span class="hljs-number">0</span>) {
				score = INT_MAX/<span class="hljs-number">2</span> - (index &lt;&lt; <span class="hljs-number">2</span>);	<span class="hljs-comment">// 评分</span>
				<span class="hljs-keyword">break</span>;
			}
		}
		<span class="hljs-keyword">if</span> (!score)
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	}
	...
	<span class="hljs-keyword">return</span> score;
}
</div></code></pre>
<pre><code class="language-C"><div><span class="hljs-comment">/* /include/linux/of.h */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> of_compat_cmp(s1, s2, l)	strcasecmp((s1), (s2))</span>
<span class="hljs-comment">/* /lib/string.c  */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcasecmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s2)</span>	<span class="hljs-comment">// 忽略大小写比较字符串</span>
</span>{
	<span class="hljs-keyword">int</span> c1, c2;
	<span class="hljs-keyword">do</span> {
		c1 = <span class="hljs-built_in">tolower</span>(*s1++);
		c2 = <span class="hljs-built_in">tolower</span>(*s2++);
	} <span class="hljs-keyword">while</span> (c1 == c2 &amp;&amp; c1 != <span class="hljs-number">0</span>);
	<span class="hljs-keyword">return</span> c1 - c2;
}
</div></code></pre>
<p>整体匹配流程如下：</p>
<center>
<img src="https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/%E8%AE%BE%E5%A4%87%E6%A0%91%E5%8C%B9%E9%85%8D%E6%9C%BA%E5%88%B6.png?raw=true" width="90%" />
</center>
<blockquote>
<p>注：除了设备树匹配所调用的函数从<code>of_driver_match_device</code>变成<code>i2c_of_match_device</code>，其余地方相差不大。其他总线(如platform，SPI)都是依照上图流程进行匹配，所以就不进行修改了。</p>
</blockquote>
<div STYLE="page-break-after: always;"></div>
<h1 id="5-结语">5. 结语</h1>
<p>本文对Linux中I2C驱动框架进行了简单的介绍。通过分析整体架构和代码结构，了解各个组成部分的功能和相互联系。重点对I2C驱动框架的核心层、总线驱动、设备驱动的代码实现流程进行梳理。并深入分析了<code>probe()</code>和<code>match()</code>函数的调用时机以及设备树匹配机制。</p>
<h1 id="6-参考资料">6. 参考资料</h1>
<ul>
<li>Linux内核源码：<code>.../OpenHarmony/out/kernel/src_tmp/linux-5.10/</code></li>
<li>《Linux设备驱动开发详解》
<ul>
<li>第15章 《Linux I2C核心、总线与设备驱动》</li>
<li>第18章 《ARM Linux 设备树》</li>
</ul>
</li>
<li><a href="https://www.csdn.net/tags/MtjacgxsOTA2MzQtYmxvZwO0O0OO0O0O.html">i2c驱动移植流程</a></li>
<li><a href="https://blog.csdn.net/fang_yang_wa/article/details/113344992">Linux驱动分析——I2C子系统</a></li>
<li><a href="https://blog.csdn.net/weixin_45842280/article/details/120737457?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-120737457-blog-126225958.pc_relevant_multi_platform_whitelistv4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-120737457-blog-126225958.pc_relevant_multi_platform_whitelistv4&amp;utm_relevant_index=3">linux驱动之I2C子系统</a></li>
<li><a href="https://blog.csdn.net/qq_28515331/article/details/93196889?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-93196889-blog-90739753.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-93196889-blog-90739753.pc_relevant_aa&amp;utm_relevant_index=5">基于RK3399的Linux驱动开发 -- I2C驱动框架</a></li>
<li><a href="https://www.cnblogs.com/DF11G/p/16008437.html">Linux I2C驱动整理（以RK3399Pro+Kernel 4.4为例）</a></li>
<li><a href="https://blog.csdn.net/weixin_42129680/article/details/113736259">I2C适配器驱动及设备驱动代码详解</a></li>
<li><a href="https://blog.csdn.net/cmh477660693/article/details/54577453">Linux驱动之I2C总线驱动开发</a></li>
<li><a href="https://blog.csdn.net/weixin_42031299/article/details/125610751?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-125610751-blog-113344992.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-125610751-blog-113344992.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=2">linux内核I2C子系统详解——看这一篇就够了</a></li>
<li><a href="https://blog.csdn.net/weixin_43555423/article/details/90739753">I2C协议和驱动框架分析（二）</a></li>
<li><a href="https://blog.csdn.net/zz2633105/article/details/117384201">【linux iic子系统】i2c整体框图【精髓部分】（五）</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1914836">Linux系统驱动之I2C_Adapter驱动框架讲解与编写</a></li>
<li><a href="https://blog.csdn.net/qq_40629752/article/details/107943500">Input子系统-Touch Screen</a></li>
<li><a href="https://www.elecfans.com/d/1434120.html">i2c的设备树和驱动是如何匹配以及何时调用probe的</a></li>
<li><a href="https://blog.csdn.net/weixin_42031299/article/details/125359621">I2C子系统之适配器的设备接口分析(i2c-dev.c文件分析)</a></li>
</ul>

        
        
    </body>
    </html>